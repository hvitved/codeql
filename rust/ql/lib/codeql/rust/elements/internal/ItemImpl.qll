// generated by codegen, remove this comment if you wish to edit this file
/**
 * This module provides a hand-modifiable wrapper around the generated class `Item`.
 *
 * INTERNAL: Do not use.
 */

private import codeql.rust.elements.internal.generated.Item

/**
 * INTERNAL: This module contains the customizable definition of `Item` and should not
 * be referenced directly.
 */
module Impl {
  /**
   * A Item. For example:
   * ```rust
   * todo!()
   * ```
   */
  class Item extends Generated::Item { }

  private import rust
  private import codeql.rust.elements.internal.generated.ParentChild

  private class NamedItem extends Item {
    private string name;

    NamedItem() {
      name = this.(Const).getName().getText()
      or
      name = this.(Enum).getName().getText()
      or
      name = this.(Function).getName().getText()
      or
      name = this.(Module).getName().getText()
      or
      name = this.(Struct).getName().getText()
      or
      name = this.(Trait).getName().getText()
      or
      name = this.(Union).getName().getText()
      or
      this instanceof Use and
      name = "(use)"
    }

    Visibility getVisibility() {
      result = this.(Const).getVisibility()
      or
      result = this.(Enum).getVisibility()
      or
      result = this.(Function).getVisibility()
      or
      result = this.(Module).getVisibility()
      or
      result = this.(Struct).getVisibility()
      or
      result = this.(Trait).getVisibility()
      or
      result = this.(Union).getVisibility()
      or
      result = this.(Use).getVisibility()
    }

    bindingset[this]
    pragma[inline_late]
    predicate isPublic() { exists(this.getVisibility()) }

    string getName() { result = name }
  }

  pragma[nomagic]
  private Element getAnItemDescendant(NamedItem item) {
    getImmediateParent(result) = item
    or
    exists(Element mid |
      mid = getAnItemDescendant(item) and
      getImmediateParent(result) = mid and
      not mid instanceof NamedItem
    )
  }

  pragma[nomagic]
  private NamedItem getImmediateParentItem(NamedItem item) { item = getAnItemDescendant(result) }

  pragma[nomagic]
  private NamedItem getItemAncestorNonModule(NamedItem item) {
    (
      result = getImmediateParentItem(item)
      or
      exists(NamedItem mid |
        mid = getItemAncestorNonModule(item) and
        result = getImmediateParentItem(mid) and
        not mid instanceof Module
      )
    )
  }

  pragma[nomagic]
  private Module getImmediateParentModule(NamedItem item) {
    result = getItemAncestorNonModule(item)
  }

  private predicate sourceFileEdge(SourceFile f, NamedItem item) { item = f.getAnItem() }

  pragma[nomagic]
  private predicate sourceFileEdge(SourceFile f, string name, NamedItem item) {
    (
      sourceFileEdge(f, item)
      or
      exists(Use use |
        sourceFileEdge(f, _, use) and
        itemEdge(use, item)
      )
    ) and
    name = item.getName()
  }

  pragma[nomagic]
  private predicate itemEdge(NamedItem item1, NamedItem item2) {
    item1 = getImmediateParentItem(item2)
    or
    fileImportEdge(item1, item2)
    or
    useImportEdge(item1, item2)
  }

  pragma[nomagic]
  private predicate itemEdge(NamedItem item1, string name, NamedItem item2) {
    (
      itemEdge(item1, item2)
      or
      exists(Use use |
        itemEdge(item1, _, use) and
        itemEdge(use, item2)
      )
    ) and
    name = item2.getName()
    or
    name = "super" and
    if item1 instanceof Module
    then item2 = getImmediateParentModule(item1)
    else item2 = getImmediateParentModule(getImmediateParentModule(item1))
  }

  /** Holds if `f` is available as `mod name;` inside `folder`. */
  private predicate fileModule(SourceFile f, string name, Folder folder) {
    exists(File file | file = f.getFile() |
      file.getBaseName() = name + ".rs" and
      folder = file.getParentContainer()
      or
      exists(Folder encl |
        file.getBaseName() = "mod.rs" and
        encl = file.getParentContainer() and
        name = encl.getBaseName() and
        folder = encl.getParentContainer()
      )
    )
  }

  /** Holds if `m` is a `mod name;` item importing file `f`. */
  private predicate fileImport(Module m, SourceFile f) {
    exists(string name |
      not m.hasItemList() and
      // TODO: handle
      // ```
      // #[path = "foo.rs"]
      // mod bar;
      // ```
      not m.getAnAttr().getMeta().getPath().getPart().getNameRef().getText() = "path" and
      name = m.getName().getText() and
      fileModule(f, name, m.getFile().getParentContainer())
    )
  }

  /**
   * Holds if `mod` is a `mod name;` item resulting in the item path
   * `head::modPath` being valid. The new path is valid because
   * `filePath` is valid within the file that gets imported.
   */
  private predicate fileImportEdge(Module mod, NamedItem item) {
    item.isPublic() and
    exists(SourceFile f |
      fileImport(mod, f) and
      sourceFileEdge(f, item)
    )
  }

  pragma[nomagic]
  private predicate rootPath(Path path, string name, SourceFile f, NamedItem scope) {
    exists(NamedItem encl |
      f.getAnItem() = getImmediateParentItem*(scope) and
      getAnItemDescendant(encl) = path and
      scope = [encl, getImmediateParentModule(encl).(NamedItem)] and
      not exists(path.getQualifier()) and
      not path = any(UseTreeList list).getAUseTree().getPath() and // todo
      name = path.getPart().getNameRef().getText()
    )
  }

  pragma[nomagic]
  Item resolveItem(Path path) {
    exists(SourceFile f, NamedItem encl, string name | rootPath(path, name, f, encl) |
      itemEdge(encl, name, result)
      or
      sourceFileEdge(f, name, result)
    )
    or
    exists(Item q |
      q = resolveItem(path.getQualifier()) and
      itemEdge(q, path.getPart().getNameRef().getText(), result)
    )
  }

  /** Holds if `m` is a `mod name;` item importing file `f`. */
  pragma[nomagic]
  private predicate useImportEdge(Use use, NamedItem item) {
    // imported item must be `pub`
    item.isPublic() and
    exists(UseTree tree, Path path, NamedItem used |
      tree = use.getUseTree() and
      path = tree.getPath() and
      used = resolveItem(path) and
      // todo: handle `getUseTreeList`
      not exists(tree.getUseTreeList()) and
      if used instanceof Module
      then
        // glob import
        itemEdge(used, item)
      else item = used
    )
  }
  // /** A crate. */
  // class Crate extends File {
  //   Crate() { this.getBaseName() = "Cargo.toml" }
  //   pragma[nomagic]
  //   Item getItem() {
  //     exists(SourceFile file |
  //       file.getFile().getParentContainer() = this.getParentContainer() and
  //       file.getAnItem() = result
  //     )
  //   }
  // }
}
