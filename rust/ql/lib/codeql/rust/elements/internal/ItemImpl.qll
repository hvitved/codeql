// generated by codegen, remove this comment if you wish to edit this file
/**
 * This module provides a hand-modifiable wrapper around the generated class `Item`.
 *
 * INTERNAL: Do not use.
 */

private import codeql.rust.elements.internal.generated.Item

/**
 * INTERNAL: This module contains the customizable definition of `Item` and should not
 * be referenced directly.
 */
module Impl {
  /**
   * A Item. For example:
   * ```rust
   * todo!()
   * ```
   */
  class Item extends Generated::Item { }

  private import rust
  private import codeql.rust.elements.internal.generated.ParentChild

  private class NamedItem extends Item {
    private string name;

    NamedItem() {
      name = this.(Const).getName().getText()
      or
      name = this.(Enum).getName().getText()
      or
      name = this.(Function).getName().getText()
      or
      name = this.(Module).getName().getText()
      or
      name = this.(Struct).getName().getText()
      or
      name = this.(Trait).getName().getText()
      or
      name = this.(Union).getName().getText()
      or
      this instanceof Use and
      name = "(use)"
    }

    Visibility getVisibility() {
      result = this.(Const).getVisibility()
      or
      result = this.(Enum).getVisibility()
      or
      result = this.(Function).getVisibility()
      or
      result = this.(Module).getVisibility()
      or
      result = this.(Struct).getVisibility()
      or
      result = this.(Trait).getVisibility()
      or
      result = this.(Union).getVisibility()
      or
      result = this.(Use).getVisibility()
    }

    bindingset[this]
    pragma[inline_late]
    predicate isPublic() { exists(this.getVisibility()) }

    string getName() { result = name }
  }

  pragma[nomagic]
  private Element getAnItemDescendant(NamedItem item) {
    getImmediateParent(result) = item
    or
    exists(Element mid |
      mid = getAnItemDescendant(item) and
      getImmediateParent(result) = mid and
      not mid instanceof NamedItem
    )
  }

  pragma[nomagic]
  private NamedItem getImmediateParentItem(NamedItem item) { item = getAnItemDescendant(result) }

  pragma[nomagic]
  private NamedItem getItemAncestorNonModule(NamedItem item) {
    (
      result = getImmediateParentItem(item)
      or
      exists(NamedItem mid |
        mid = getItemAncestorNonModule(item) and
        result = getImmediateParentItem(mid) and
        not mid instanceof Module
      )
    )
  }

  pragma[nomagic]
  private Module getImmediateParentModule(NamedItem item) {
    result = getItemAncestorNonModule(item)
  }

  private predicate sourceFileEdge(SourceFile f, NamedItem item) { item = f.getAnItem() }

  pragma[nomagic]
  private predicate sourceFileEdge(SourceFile f, string name, NamedItem item) {
    sourceFileEdge(f, item) and
    name = item.getName()
    or
    exists(Use use |
      sourceFileEdge(f, use) and
      itemEdge(use, name, item)
    )
  }

  pragma[nomagic]
  private predicate itemEdge(NamedItem item1, string name, NamedItem item2) {
    item1 = getImmediateParentItem(item2) and
    name = item2.getName()
    or
    fileImportEdge(item1, item2) and
    name = item2.getName()
    or
    useImportEdge(item1, name, item2)
    or
    exists(Use use |
      itemEdge(item1, _, use) and
      itemEdge(use, name, item2)
    )
    or
    name = "super" and
    if item1 instanceof Module
    then item2 = getImmediateParentModule(item1)
    else item2 = getImmediateParentModule(getImmediateParentModule(item1))
  }

  /** Holds if `f` is available as `mod name;` inside `folder`. */
  private predicate fileModule(SourceFile f, string name, Folder folder) {
    exists(File file | file = f.getFile() |
      file.getBaseName() = name + ".rs" and
      folder = file.getParentContainer()
      or
      exists(Folder encl |
        file.getBaseName() = "mod.rs" and
        encl = file.getParentContainer() and
        name = encl.getBaseName() and
        folder = encl.getParentContainer()
      )
    )
  }

  /** Holds if `m` is a `mod name;` item importing file `f`. */
  private predicate fileImport(Module m, SourceFile f) {
    exists(string name |
      not m.hasItemList() and
      // TODO: handle
      // ```
      // #[path = "foo.rs"]
      // mod bar;
      // ```
      not m.getAnAttr().getMeta().getPath().getPart().getNameRef().getText() = "path" and
      name = m.getName().getText() and
      fileModule(f, name, m.getFile().getParentContainer())
    )
  }

  /**
   * Holds if `mod` is a `mod name;` item resulting in the item path
   * `head::modPath` being valid. The new path is valid because
   * `filePath` is valid within the file that gets imported.
   */
  private predicate fileImportEdge(Module mod, NamedItem item) {
    item.isPublic() and
    exists(SourceFile f |
      fileImport(mod, f) and
      sourceFileEdge(f, item)
    )
  }

  pragma[nomagic]
  private predicate rootPath(Path path, string name) {
    not exists(path.getQualifier()) and
    not path = any(UseTreeList list).getAUseTree().getPath() and // todo
    name = path.getPart().getNameRef().getText()
  }

  pragma[nomagic]
  private predicate useTreeIsGlobImport(UseTree use) {
    // todo: the extractor should provide this information
    use.getLocation() != use.getPath().getLocation() and
    not use.hasUseTreeList() and
    not use.hasRename()
  }

  private predicate useTreeDeclares(UseTree tree, string name) {
    not useTreeIsGlobImport(tree) and
    not exists(tree.getUseTreeList()) and
    (
      name = tree.getRename().getName().getText()
      or
      not tree.hasRename() and
      name = tree.getPath().getPart().getNameRef().getText()
    )
    or
    exists(UseTree mid |
      useTreeDeclares(mid, name) and
      mid = tree.getUseTreeList().getAUseTree()
    )
  }

  pragma[nomagic]
  private predicate declares(NamedItem item, string name) {
    exists(NamedItem child | getImmediateParentItem(child) = item |
      child.getName() = name
      or
      useTreeDeclares(child.(Use).getUseTree(), name)
    )
  }

  pragma[nomagic]
  private predicate rootPath(Path path, string name, NamedItem scope) {
    rootPath(path, name) and
    getAnItemDescendant(scope) = path
    or
    exists(NamedItem mid |
      rootPath(path, name, mid) and
      not mid instanceof Module and
      scope = getImmediateParentItem(mid) and
      not declares(mid, name)
    )
  }

  pragma[nomagic]
  private Item resolveSourceFileEdge(Path path, string name, NamedItem scope) {
    rootPath(path, pragma[only_bind_into](name), scope) and
    exists(SourceFile f |
      f.getAnItem() = [scope, getImmediateParentItem*(scope.(Module))] and
      sourceFileEdge(f, pragma[only_bind_into](name), result)
    )
  }

  pragma[nomagic]
  NamedItem resolveItem(Path path) {
    exists(NamedItem encl, string name |
      rootPath(path, name, encl) and
      itemEdge(encl, name, result)
      or
      result = resolveSourceFileEdge(path, name, encl) and
      not declares(encl, name)
    )
    or
    exists(Item q |
      q = resolveItem(path.getQualifier()) and
      itemEdge(q, path.getPart().getNameRef().getText(), result)
    )
    or
    result = resolveUseTreeListItem(_, _, path)
  }

  private predicate isUseTreeSubPath(UseTree tree, Path path) {
    path = tree.getPath()
    or
    exists(Path mid |
      isUseTreeSubPath(tree, mid) and
      path = mid.getQualifier()
    )
  }

  pragma[nomagic]
  NamedItem resolveUseTreeListItem(Use use, UseTree tree, Path path) {
    exists(UseTree midTree, NamedItem mid |
      mid = resolveUseTreeListItem(use, midTree) and
      tree = midTree.getUseTreeList().getAUseTree() and
      isUseTreeSubPath(tree, path) and
      not exists(path.getQualifier()) and
      itemEdge(mid, path.getPart().getNameRef().getText(), result)
    )
    or
    exists(NamedItem mid |
      mid = resolveUseTreeListItem(use, tree, path.getQualifier()) and
      itemEdge(mid, path.getPart().getNameRef().getText(), result)
    )
  }

  pragma[nomagic]
  NamedItem resolveUseTreeListItem(Use use, UseTree tree) {
    tree = use.getUseTree() and
    result = resolveItem(tree.getPath())
    or
    result = resolveUseTreeListItem(use, tree, tree.getPath())
  }

  /** Holds if `use` imports `item` as `name`. */
  pragma[nomagic]
  private predicate useImportEdge(Use use, string name, NamedItem item) {
    exists(UseTree tree, NamedItem used |
      used = resolveUseTreeListItem(use, tree) and
      not exists(tree.getUseTreeList()) and
      if useTreeIsGlobImport(tree)
      then
        // glob import
        itemEdge(used, name, item)
      else item = used
    |
      not tree.hasRename() and
      name = item.getName()
      or
      name = tree.getRename().getName().getText()
    )
  }
  // /** A crate. */
  // class Crate extends File {
  //   Crate() { this.getBaseName() = "Cargo.toml" }
  //   pragma[nomagic]
  //   Item getItem() {
  //     exists(SourceFile file |
  //       file.getFile().getParentContainer() = this.getParentContainer() and
  //       file.getAnItem() = result
  //     )
  //   }
  // }
}
